// Code generated by go-swagger;
// Code was edited; DO NOT USE GENERATE FOR THIS FILE
// Use generate with flag --exclude-main

package main

import (
	"context"
	"os"

	log "github.com/sirupsen/logrus"

	"github.com/alexflint/go-arg"
	"github.com/go-openapi/loads"
	flags "github.com/jessevdk/go-flags"

	"hashkeeper/internal/application"
	"hashkeeper/internal/domain/calculate"
	"hashkeeper/internal/domain/find"
	"hashkeeper/internal/infrastructure/psqlrepo"
	"hashkeeper/internal/interfaces/grpccalc"
	swaggerserversrv "hashkeeper/internal/interfaces/restapi/server"
	"hashkeeper/internal/interfaces/restapi/server/operations"
	"hashkeeper/pkg/hashlog"
)

// This file was generated by the swagger tool.
// Make sure not to overwrite this file after you generated it because all your edits would be lost!

type Args struct {
	hashlog.LogCfg
	grpccalc.HashMakerCfg
	psqlrepo.HashRepositoryCfg
	swaggerserversrv.RESTAPICfg
}

func main() {
	var args Args
	arg.MustParse(&args)

	hashlog.InitLog(args.LogCfg)

	log.Info("hashkeeper is starting...")

	log.Infof("start arguments: %+v", args)

	swaggerSpec, err := loads.Embedded(swaggerserversrv.SwaggerJSON, swaggerserversrv.FlatSwaggerJSON)
	if err != nil {
		hashlog.LogErrorWithStack(err).Fatal("failed to init HTTP server")
	}

	api := operations.NewHashkeeperAPI(swaggerSpec)
	server := swaggerserversrv.NewServer(api)
	defer server.Shutdown()

	parser := flags.NewParser(server, flags.Default|flags.IgnoreUnknown)
	parser.ShortDescription = "Итоговое задание. Хэши."
	parser.LongDescription = "Данный сервис должен, взаимодействуя с сервисом считающим хэши (по выбранному вами протоколу), получать из входящих строк их хэши, сохранять их в свою БД (выбор так же за вами) с присвоением id, по которым далее можно будет запрашивать хэши."
	server.ConfigureFlags()
	for _, optsGroup := range api.CommandLineOptionsGroups {
		_, err := parser.AddGroup(optsGroup.ShortDescription, optsGroup.LongDescription, optsGroup.Options)
		if err != nil {
			hashlog.LogErrorWithStack(err).Fatal("failed to config HTTP server")
		}
	}

	if _, err := parser.Parse(); err != nil {
		code := 1
		if fe, ok := err.(*flags.Error); ok {
			if fe.Type == flags.ErrHelp {
				code = 0
			}
		}
		os.Exit(code)
	}

	server.ConfigureAPI()

	// Init app

	app := initApp(args)

	if err := setApp(app, args.RESTAPICfg); err != nil {
		hashlog.LogErrorWithStack(err).Fatal("failed to setup REST API server")
	}

	// Start server

	log.Info("started, waiting for request ...")

	if err := server.Serve(); err != nil {
		hashlog.LogErrorWithStack(err).Fatal("failed to start HTTP server")
	}

}

func initApp(args Args) application.App {
	hashMaker, err := grpccalc.NewHashMaker(args.HashMakerCfg)
	if err != nil {
		hashlog.LogErrorWithStack(err).Fatal("can`t create grpc hash maker")
	}

	err = hashMaker.Dial(context.Background())
	if err != nil {
		hashlog.LogErrorWithStack(err).Fatal("can`t dial grpc hash maker")
	}

	hashRepo, err := psqlrepo.NewHashRepository(args.HashRepositoryCfg)
	if err != nil {
		hashlog.LogErrorWithStack(err).Fatal("can`t create psql hash repository")
	}

	err = hashRepo.Dial(context.Background())
	if err != nil {
		hashlog.LogErrorWithStack(err).Fatal("can`t dial psql hash repository")
	}

	calcHandler := calculate.NewCalculateHandler(hashMaker, hashRepo)

	findHandler := find.NewFindHandler(hashRepo)

	shutdownFunc := func() {
		log.Info("hashkeeper is shutting down...")

		if err := hashMaker.Close(); err != nil {
			hashlog.LogErrorWithStack(err).Error("failed to close hash maker")
		}

		if err := hashRepo.Close(); err != nil {
			hashlog.LogErrorWithStack(err).Error("failed to close hash repository")
		}
	}

	app := application.NewApp(calcHandler, findHandler, shutdownFunc)

	return app
}

func setApp(app application.App, cfg swaggerserversrv.RESTAPICfg) error {
	return swaggerserversrv.InitServer(app, cfg)
}
